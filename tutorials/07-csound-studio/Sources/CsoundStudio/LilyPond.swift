import Foundation

enum LilyPondExporter {
    static func makeLily(from csd: String, tempoBPM: Int) -> String {
        // naive: assume a single voice; map i-lines to equal-tempered notes by heuristic (not exact)
        func midi(for freq: Double) -> Int { guard freq > 0 else { return 60 }; return Int((69.0 + 12.0 * log2(freq / 440.0)).rounded()) }
        let names = ["c","cis","d","dis","e","f","fis","g","gis","a","ais","b"]
        func lilyName(_ midiNote: Int) -> String {
            let pc = (midiNote % 12 + 12) % 12
            let base = names[pc]
            let d = (midiNote - 60) / 12
            return d >= 0 ? base + String(repeating: "'", count: d + 1) : base + String(repeating: ",", count: -d - 1)
        }
        let quarter = 60.0 / Double(tempoBPM)
        let denoms: [Int] = [1,2,4,8,16]
        struct Cand { let ratio: Double; let label: String }
        func durToken(_ sec: Double) -> String {
            let ratio = sec / quarter
            var best = Cand(ratio: Double.greatestFiniteMagnitude, label: "4")
            var bestDiff = Double.greatestFiniteMagnitude
            for d in denoms {
                let base = 4.0 / Double(d)
                let plain = Cand(ratio: base, label: String(d))
                let dotted = Cand(ratio: base * 1.5, label: String(d) + ".")
                for c in [plain, dotted] { let diff = abs(ratio - c.ratio); if diff < bestDiff { bestDiff = diff; best = c } }
            }
            return best.label
        }

        // Extract a primary frequency if available
        var freq: Double = 440
        if let osc = csd.components(separatedBy: .newlines).first(where: { $0.contains("oscili") }) {
            let nums = osc.replacingOccurrences(of: ",", with: " ").components(separatedBy: CharacterSet(charactersIn: " -\t\n")).compactMap(Double.init)
            if nums.count >= 2 { freq = nums[1] }
        }
        // Build notes from i-lines (start,dur)
        var notes: [String] = []
        for line in csd.components(separatedBy: .newlines) where line.trimmingCharacters(in: .whitespaces).hasPrefix("i ") {
            let parts = line.split(whereSeparator: { $0.isWhitespace })
            if parts.count >= 4, let _ = Double(parts[1]), let dur = Double(parts[3]) {
                let name = lilyName(midi(for: freq))
                notes.append("\(name)\(durToken(dur))")
            }
        }
        if notes.isEmpty { notes = ["c'4"] }
        let header = """
        % Generated by CsoundStudio
        \\version "2.24.0"
        \\header { title = "Composition" tagline = "FountainAI • Csound • LilyPond" }
        """
        let tempo = "\\tempo 4 = \(tempoBPM)"
        let body = "{\n  \(tempo)\n  \(notes.joined(separator: " "))\n}"
        return [header, body].joined(separator: "\n")
    }

    static func engrave(lyURL: URL) -> Bool {
        let task = Process()
        task.executableURL = URL(fileURLWithPath: "/usr/bin/env")
        task.arguments = ["lilypond", lyURL.path]
        do { try task.run(); task.waitUntilExit(); return (task.terminationStatus == 0) } catch { return false }
    }
}

